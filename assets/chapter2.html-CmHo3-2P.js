import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,d as a,o as n}from"./app-qOQMBkXC.js";const l={};function s(i,e){return n(),d("div",null,e[0]||(e[0]=[a(`<h2 id="章节总览" tabindex="-1"><a class="header-anchor" href="#章节总览"><span>章节总览</span></a></h2><p>本章系统阐述 Ascend CANN 软件栈的分层结构、模型从框架格式到 OM 的转换原理、转换工具 ATC 的关键参数、OM 文件组织结构、AscendCL (ACL) 推理编程模型、精度与性能验证方法以及工程级质量保障流水线建设。阅读完成后应满足：</p><ol><li>能解释 Driver / Runtime / Compiler / Toolkit / ACL 各组件职责及交互边界。</li><li>能为任意主流视觉模型编写一份无二义性的 ATC 转换命令并说明参数意义。</li><li>能通过脚本解析 OM 模型的输入输出信息、算子统计与内存占用估算。</li><li>能以 C 或 Python 写出健壮的最小推理程序（含异常处理与资源释放）。</li><li>能定位转换/推理常见错误，给出复现、分析与修复路径。</li><li>能构建“转换 → 精度对齐 → 性能基线 → 回归监测”的自动流水线。</li></ol><h2 id="cann-软件栈分层与数据流" tabindex="-1"><a class="header-anchor" href="#cann-软件栈分层与数据流"><span>CANN 软件栈分层与数据流</span></a></h2><table><thead><tr><th>层级</th><th>组件</th><th>核心职责</th><th>典型交互</th></tr></thead><tbody><tr><td>硬件抽象</td><td>Driver</td><td>设备初始化、资源枚举、功耗/温度接口</td><td>npu-smi / Runtime</td></tr><tr><td>运行时</td><td>Runtime</td><td>上下文(Context)管理、Stream/Task 调度、内存分配</td><td>ACL / Compiler</td></tr><tr><td>编译优化</td><td>Graph Compiler</td><td>图解析、拓扑排序、算子匹配、内存复用、算子融合</td><td>ATC / Runtime</td></tr><tr><td>工具链</td><td>Toolkit</td><td>ATC 转换、Profiling、Dump、可视化、日志</td><td>开发者</td></tr><tr><td>API 层</td><td>AscendCL</td><td>C 接口封装：模型管理 / 内存 / 数据传输 / 执行</td><td>应用</td></tr></tbody></table><p>数据流（框架模型 → OM → 推理）核心阶段：</p><ol><li>前端导出：PyTorch → ONNX（维度常量化、算子展开）。</li><li>ATC 编译：图解析 → Shape Infer → 算子选择 → Kernel 排布 → 内存映射 → 生成 OM（二进制 + 元数据段）。</li><li>运行加载：aclmdlLoadFromFile 读取 OM Header，分配 Device 内存，构建执行计划（Task 列表）。</li><li>推理执行：Host 侧准备输入 → H2D 拷贝 → Runtime 提交 Task → 硬件执行 → D2H 拷贝 → 后处理。</li></ol><h2 id="环境一致性与安装验证" tabindex="-1"><a class="header-anchor" href="#环境一致性与安装验证"><span>环境一致性与安装验证</span></a></h2><p>环境差异是隐性失败根源，建议形成“安装后自检”脚本，校验以下要点：</p><ol><li>版本矩阵：固件/Driver/CANN/ATC 必须在官方 Release Note 支持组合内。</li><li>环境变量：<code>ASCEND_INSTALL_PATH</code> 指向安装根；<code>LD_LIBRARY_PATH</code> 中包含 <code>driver</code> 与 <code>runtime/lib64</code>；Python 绑定需在 <code>PYTHONPATH</code> 中。</li><li>设备可见：<code>npu-smi info</code> 返回芯片型号 <code>Ascend310B</code> 且状态正常，无 <code>Fault</code> 标记。</li><li>转换工具：<code>atc --version</code> 输出版本与期望匹配；<code>atc --help</code> 能正常列出参数。</li><li>运行权限：当前用户具备访问 <code>/dev/davinci*</code> 设备节点读写权限（若无，加入相应用户组或 udev 规则）。</li><li>Python 依赖：<code>numpy</code>, <code>onnx</code>, <code>onnxruntime</code> (精度对齐), <code>pyyaml</code>, 自编写工具包。</li></ol><h2 id="模型准备与输入规范统一" tabindex="-1"><a class="header-anchor" href="#模型准备与输入规范统一"><span>模型准备与输入规范统一</span></a></h2><table><thead><tr><th>项</th><th>说明</th><th>决策标准</th></tr></thead><tbody><tr><td>边界 Shape</td><td>静态 or 动态</td><td>场景多尺寸/Batch 波动？</td></tr><tr><td>Layout</td><td>NCHW / NHWC</td><td>上游预处理 &amp; 算子最佳实现</td></tr><tr><td>颜色空间</td><td>RGB / BGR / YUV</td><td>原始采集格式 + 算子期望</td></tr><tr><td>归一化</td><td>mean/std / scale</td><td>训练环节定义必须完全对齐</td></tr><tr><td>精度策略</td><td>FP16 / INT8</td><td>性能目标 &amp; 可接受精度损失</td></tr><tr><td>Quant 校准集</td><td>代表性样本</td><td>覆盖亮度/场景/尺寸多样性</td></tr></tbody></table><p>核心风险：训练与部署输入不一致（尺寸拉伸方式、通道顺序、归一化顺序、色彩空间转换位置）。必须输出“输入契约文件”（JSON/YAML）标注：<code>shape</code>、<code>dtype</code>、<code>layout</code>、<code>color_space</code>、<code>mean/std</code>、<code>range</code>、<code>precision_mode</code>。</p><h2 id="atc-模型转换详解" tabindex="-1"><a class="header-anchor" href="#atc-模型转换详解"><span>ATC 模型转换详解</span></a></h2><p>典型命令（以 ResNet50 为例，支持 FP16）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>atc \\</span></span>
<span class="line"><span>  --model=resnet50.onnx \\</span></span>
<span class="line"><span>  --framework=5 \\</span></span>
<span class="line"><span>  --output=resnet50_fp16 \\</span></span>
<span class="line"><span>  --input_format=NCHW \\</span></span>
<span class="line"><span>  --input_shape=&quot;input:1,3,224,224&quot; \\</span></span>
<span class="line"><span>  --soc_version=Ascend310B \\</span></span>
<span class="line"><span>  --precision_mode=allow_fp32_to_fp16 \\</span></span>
<span class="line"><span>  --op_select_implmode=high_performance \\</span></span>
<span class="line"><span>  --log=info \\</span></span>
<span class="line"><span>  --insert_op_conf=aipp.cfg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键参数说明：</p><table><thead><tr><th>参数</th><th>作用</th><th>注意事项</th></tr></thead><tbody><tr><td><code>--framework</code></td><td>输入框架类型 (5=ONNX)</td><td>与实际导出一致，否则形状推理异常</td></tr><tr><td><code>--input_shape</code></td><td>静态 shape 指定</td><td>多输入以逗号分隔 <code>in1:1,3,224,224;in2:1,128</code></td></tr><tr><td><code>--dynamic_batch_size</code></td><td>动态 Batch</td><td>与 <code>--input_shape</code> 不能混用静态冲突</td></tr><tr><td><code>--dynamic_image_size</code></td><td>动态分辨率</td><td>YOLO 等多尺度部署</td></tr><tr><td><code>--precision_mode</code></td><td>精度策略</td><td><code>allow_mix_precision</code>、<code>allow_fp32_to_fp16</code></td></tr><tr><td><code>--soc_version</code></td><td>硬件目标</td><td>与实际芯片匹配；310B 与 310P 不可混淆</td></tr><tr><td><code>--insert_op_conf</code></td><td>AIPP(预处理)</td><td>可下沉色彩空间转换、均值/方差</td></tr><tr><td><code>--op_select_implmode</code></td><td>算子实现优先级</td><td><code>high_precision</code> vs <code>high_performance</code></td></tr><tr><td><code>--input_format</code></td><td>模型输入排布</td><td>与 <code>--input_shape</code> 一致性检查</td></tr><tr><td><code>--output_type</code></td><td>输出 dtype</td><td>常用于 INT8 推理后转 FP32 便于后处理</td></tr><tr><td><code>--enable_small_channel</code></td><td>小通道优化</td><td>某些轻量网络加速</td></tr></tbody></table><h3 id="自定义算子加载" tabindex="-1"><a class="header-anchor" href="#自定义算子加载"><span>自定义算子加载</span></a></h3><ol><li>定义 JSON 描述（输入输出、属性）。</li><li>编写 Kernel 源码并使用官方编译脚本生成 <code>.so</code>。</li><li>ATC 阶段通过 <code>--optypelist_for_impl</code> 或 <code>--soc_version</code> + JSON 注册；运行时放置在 <code>ASCEND_OPP_PATH</code> 对应目录。</li></ol><h3 id="日志与告警" tabindex="-1"><a class="header-anchor" href="#日志与告警"><span>日志与告警</span></a></h3><p>常见告警分类：</p><ul><li>未使用节点 (prune) → 确认是否为训练辅助算子 (e.g., Dropout)。</li><li>算子降级 → 检查是否 fallback 到 Host；对性能敏感需重写/替换结构。</li><li>精度截断 → 记录发生算子，评估对最终指标影响；必要时关闭相关优化策略。</li></ul><h2 id="om-文件结构解读" tabindex="-1"><a class="header-anchor" href="#om-文件结构解读"><span>OM 文件结构解读</span></a></h2><p>OM 通常包含：</p><ol><li>Header：魔数、版本、输入输出 Tensor 数、DataType、Format。</li><li>Graph Meta：节点拓扑、算子类型列表、权重偏移指针。</li><li>Weights Segment：连续存放常量权重与常量张量。</li><li>Task List：调度指令列表（Kernel Launch / MemCopy / Event）。</li><li>AIPP 配置（可选）：预处理算子参数表。</li></ol><h3 id="解析与统计脚本要点" tabindex="-1"><a class="header-anchor" href="#解析与统计脚本要点"><span>解析与统计脚本要点</span></a></h3><ul><li>调用 <code>aclmdlQuerySize</code> 得到模型工作内存与权重内存需求。</li><li>利用 <code>aclmdlGetInputIndexByName</code> / <code>aclmdlGetInputDims</code> 获取 IO 维度与 dtype。</li><li>自建表格：<code>{op_type: count}</code> 用于识别热点类型（后续优化参考）。</li></ul><h2 id="acl-推理编程模型" tabindex="-1"><a class="header-anchor" href="#acl-推理编程模型"><span>ACL 推理编程模型</span></a></h2><p>典型生命周期：</p><ol><li>初始化：<code>aclInit</code> → <code>aclrtSetDevice</code> → <code>aclrtCreateContext</code> → (可选) 创建 Stream。</li><li>模型：<code>aclmdlLoadFromFile</code> → 查询 IO 描述 → 预分配 Device Buffer。</li><li>数据准备：Host 侧申请内存（Pinned 优先）→ 格式/归一化 → H2D 拷贝。</li><li>执行：<code>aclmdlExecute</code> 或 异步 <code>aclmdlExecuteAsync</code> + Stream 同步。</li><li>输出处理：D2H 拷贝 → 解码 / Softmax / NMS。</li><li>资源释放：<code>aclmdlUnload</code> → Free buffers → Destroy Context → <code>aclFinalize</code>。</li></ol><h3 id="c-语言最小示例-核心片段" tabindex="-1"><a class="header-anchor" href="#c-语言最小示例-核心片段"><span>C 语言最小示例（核心片段）</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 省略错误检查宏定义 ERR_CHK</span></span>
<span class="line"><span>aclInit(NULL);</span></span>
<span class="line"><span>aclrtSetDevice(0);</span></span>
<span class="line"><span>aclrtContext ctx; aclrtCreateContext(&amp;ctx, 0);</span></span>
<span class="line"><span>uint32_t modelId; size_t wSize, rSize;</span></span>
<span class="line"><span>aclmdlLoadFromFile(&quot;resnet50_fp16.om&quot;, &amp;modelId);</span></span>
<span class="line"><span>aclmdlDesc *desc = aclmdlCreateDesc();</span></span>
<span class="line"><span>aclmdlGetDesc(desc, modelId);</span></span>
<span class="line"><span>// 输入准备</span></span>
<span class="line"><span>void *hostIn = malloc(3*224*224*2); // FP16</span></span>
<span class="line"><span>void *devIn; aclrtMalloc(&amp;devIn, 3*224*224*2, ACL_MEM_MALLOC_NORMAL_ONLY);</span></span>
<span class="line"><span>aclrtMemcpy(devIn, 3*224*224*2, hostIn, 3*224*224*2, ACL_MEMCPY_HOST_TO_DEVICE);</span></span>
<span class="line"><span>aclmdlDataset *input = aclmdlCreateDataset();</span></span>
<span class="line"><span>aclDataBuffer *inBuf = aclCreateDataBuffer(devIn, 3*224*224*2);</span></span>
<span class="line"><span>aclmdlAddDatasetBuffer(input, inBuf);</span></span>
<span class="line"><span>// 输出</span></span>
<span class="line"><span>size_t outSize = 1000 * 2; // FP16 logits</span></span>
<span class="line"><span>void *devOut; aclrtMalloc(&amp;devOut, outSize, ACL_MEM_MALLOC_NORMAL_ONLY);</span></span>
<span class="line"><span>aclmdlDataset *output = aclmdlCreateDataset();</span></span>
<span class="line"><span>aclDataBuffer *outBuf = aclCreateDataBuffer(devOut, outSize);</span></span>
<span class="line"><span>aclmdlAddDatasetBuffer(output, outBuf);</span></span>
<span class="line"><span>aclmdlExecute(modelId, input, output);</span></span>
<span class="line"><span>// 回拷</span></span>
<span class="line"><span>void *hostOut = malloc(outSize);</span></span>
<span class="line"><span>aclrtMemcpy(hostOut, outSize, devOut, outSize, ACL_MEMCPY_DEVICE_TO_HOST);</span></span>
<span class="line"><span>// 解析 softmax ...</span></span>
<span class="line"><span>// 清理省略</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="python-封装思路" tabindex="-1"><a class="header-anchor" href="#python-封装思路"><span>Python 封装思路</span></a></h3><p>官方 Python 包接口层次相似，建议封装 <code>ModelSession</code> 类：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class ModelSession:</span></span>
<span class="line"><span>    def __init__(self, om_path):</span></span>
<span class="line"><span>        self.model_id = load(om_path)</span></span>
<span class="line"><span>        self.desc = query(self.model_id)</span></span>
<span class="line"><span>        self._alloc_io_buffers()</span></span>
<span class="line"><span>    def infer(self, np_input: np.ndarray):</span></span>
<span class="line"><span>        # preprocess -&gt; copy H2D -&gt; execute -&gt; copy D2H -&gt; postprocess</span></span>
<span class="line"><span>        return logits</span></span>
<span class="line"><span>    def __del__(self):</span></span>
<span class="line"><span>        self._release()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="性能与初步调优策略" tabindex="-1"><a class="header-anchor" href="#性能与初步调优策略"><span>性能与初步调优策略</span></a></h2><table><thead><tr><th>问题</th><th>诊断信号</th><th>初级优化</th><th>进阶优化</th></tr></thead><tbody><tr><td>时延波动大</td><td>P95 &gt;&gt; P50</td><td>固定 Batch / 预热</td><td>Stream 并行 + Pin 内存</td></tr><tr><td>吞吐不足</td><td>利用率低</td><td>FP16</td><td>多实例并行</td></tr><tr><td>拷贝过多</td><td>H2D 大占比</td><td>合并预处理</td><td>AIPP 下沉</td></tr><tr><td>算子退化</td><td>日志 Fallback</td><td>替换模型结构</td><td>自定义算子</td></tr></tbody></table><p>关键早期收集指标：平均时延、P95、H2D+Pre 占比、推理核心阶段占比、内存峰值。</p><h2 id="常见错误分类与排查路径" tabindex="-1"><a class="header-anchor" href="#常见错误分类与排查路径"><span>常见错误分类与排查路径</span></a></h2><table><thead><tr><th>场景</th><th>日志/现象</th><th>根因类型</th><th>排查步骤</th><th>修复</th></tr></thead><tbody><tr><td>ATC Unsupported Op</td><td>E190xx</td><td>模型含新算子</td><td>onnxsim → 拆解</td><td>替换/重写</td></tr><tr><td>动态 Shape OOM</td><td>执行时内存溢出</td><td>最大分辨率超预算</td><td>统计输入分布</td><td>分桶/裁剪</td></tr><tr><td>精度下降</td><td>Top1 -5%</td><td>归一化差异</td><td>离线对齐脚本</td><td>修正预处理</td></tr><tr><td>输出 NAN</td><td>logits 异常</td><td>上溢/量化尺度错误</td><td>Dump 中间 Tensor</td><td>重新校准</td></tr><tr><td>设备不可见</td><td>aclInit 失败</td><td>Driver 未加载</td><td>dmesg &amp; npu-smi</td><td>重装驱动</td></tr></tbody></table><h2 id="质量保障与自动化流水线" tabindex="-1"><a class="header-anchor" href="#质量保障与自动化流水线"><span>质量保障与自动化流水线</span></a></h2><p>流水线阶段：</p><ol><li>Export：框架导出 + ONNX Simplify + 模型签名(<code>inputs/name/dtype/layout/mean/std</code>).</li><li>Convert：ATC 命令模板参数化（YAML → 渲染）。</li><li>Validate：ONNXRuntime vs OM 输出差异 (L1/L2/TopK 差异率 &lt; 阈值)。</li><li>Benchmark：Warmup N + Run M，记录 JSON <code>{avg, p50, p95, memory}</code>。</li><li>Archive：产物归档（om, atc.log, metrics.json, signature.json）。</li><li>Regression：新提交对比基线差异，超阈值报警。</li></ol><h3 id="精度对齐示例指标" tabindex="-1"><a class="header-anchor" href="#精度对齐示例指标"><span>精度对齐示例指标</span></a></h3><table><thead><tr><th>指标</th><th>计算方式</th><th>推荐阈值</th></tr></thead><tbody><tr><td>Top1 差异</td><td>abs(top1_acc_onnx - top1_acc_om)</td><td>≤0.2%</td></tr><tr><td>平均 L1</td><td>mean(</td><td>y_onnx - y_om</td></tr><tr><td>最大相对误差</td><td>max(</td><td>d</td></tr></tbody></table><h2 id="dump-profiling-调试手段" tabindex="-1"><a class="header-anchor" href="#dump-profiling-调试手段"><span>Dump / Profiling / 调试手段</span></a></h2><table><thead><tr><th>工具</th><th>使用时机</th><th>价值</th><th>代价</th></tr></thead><tbody><tr><td>Dump 中间 Tensor</td><td>精度异常</td><td>对齐中间层</td><td>I/O 与存储占用</td></tr><tr><td>Profiling Timeline</td><td>性能不达标</td><td>定位瓶颈</td><td>额外开销 (W%)</td></tr><tr><td>日志级别升高 (<code>--log=debug</code>)</td><td>转换失败</td><td>细粒度错误码</td><td>噪声多</td></tr><tr><td>校准数据捕获</td><td>INT8 偏差大</td><td>重新校准</td><td>需准备代表性样本</td></tr></tbody></table><p>Dump 配置：通过环境变量或 JSON 指定层名称白名单，避免全量 Dump 导致性能与空间压力。</p><h2 id="动态-shape-策略与内存规划" tabindex="-1"><a class="header-anchor" href="#动态-shape-策略与内存规划"><span>动态 Shape 策略与内存规划</span></a></h2><p>多分辨率/Batch 场景建议：</p><ol><li>分桶：统计历史尺寸 → 选 3~5 个“代表桶” → ATC 生成多 OM；运行时按最近桶选择。</li><li>Padding：对齐到 32/64 边界，减少算子内部分支；记录真实尺寸用于后处理。</li><li>内存预估：最大桶内存 + 安全冗余 15% 作为部署阈值，超出触发降级。</li></ol><h2 id="精度验证流程与脚本要点" tabindex="-1"><a class="header-anchor" href="#精度验证流程与脚本要点"><span>精度验证流程与脚本要点</span></a></h2><p>流程：采样输入集（校准集或验证集子集）→ ONNXRuntime 前向 → Ascend 前向 → 指标聚合 → 报告。 脚本关键：</p><ol><li>随机种子固定；</li><li>输入预处理完全共用函数；</li><li>支持逐层 Dump 比对（差异 &gt; 阈值 输出层名）。</li></ol><h2 id="安全与合规考量" tabindex="-1"><a class="header-anchor" href="#安全与合规考量"><span>安全与合规考量</span></a></h2><ul><li>模型资产：带版权或敏感权重需加密存储（考虑文件系统权限+传输校验 hash）。</li><li>日志脱敏：避免输出用户数据路径/片段；开关化控制。</li><li>Dump 数据：限定开发模式，生产禁用；数据自动过期删除策略（时间或数量）。</li></ul><h2 id="章节小结" tabindex="-1"><a class="header-anchor" href="#章节小结"><span>章节小结</span></a></h2><p>本章从宏观分层、转换编译、OM 结构、ACL 编程、性能与精度保障、调试工具、自动化流水线到动态 Shape 与安全实践建立了闭环。掌握这些内容后即可进入后续“边缘系统架构与部署实践”章节，扩展到多模型、多进程及系统级优化。</p><h2 id="实践任务" tabindex="-1"><a class="header-anchor" href="#实践任务"><span>实践任务</span></a></h2><ol><li>任选一个公开 ONNX 分类模型（如 ResNet50）完成 ATC 转换，提交：命令 + atc.log。</li><li>以 C 或 Python 实现最小推理程序，输出前 5 TopK 结果与 softmax 概率。</li><li>编写对齐脚本比较 50 张图片 ONNX vs OM 输出差异（报告 L1/Top1 差异）。</li><li>收集 Profiling Timeline，列出前 3 耗时算子类型及优化建议。</li><li>输出 <code>signature.json</code>、<code>metrics.json</code>、<code>conversion_meta.yaml</code> 并归档。</li></ol>`,61)]))}const p=t(l,[["render",s],["__file","chapter2.html.vue"]]),r=JSON.parse('{"path":"/book/chapter2.html","title":"第2讲：CANN 软件栈核心与模型转换全流程","lang":"zh-cn","frontmatter":{"title":"第2讲：CANN 软件栈核心与模型转换全流程","author":["周贤中"],"date":"2025-09-04T00:00:00.000Z","subject":"Markdown","keywords":["Ascend","CANN","模型转换","ATC","ACL","Profiling","Dump"],"lang":"zh-cn"},"headers":[{"level":2,"title":"章节总览","slug":"章节总览","link":"#章节总览","children":[]},{"level":2,"title":"CANN 软件栈分层与数据流","slug":"cann-软件栈分层与数据流","link":"#cann-软件栈分层与数据流","children":[]},{"level":2,"title":"环境一致性与安装验证","slug":"环境一致性与安装验证","link":"#环境一致性与安装验证","children":[]},{"level":2,"title":"模型准备与输入规范统一","slug":"模型准备与输入规范统一","link":"#模型准备与输入规范统一","children":[]},{"level":2,"title":"ATC 模型转换详解","slug":"atc-模型转换详解","link":"#atc-模型转换详解","children":[{"level":3,"title":"自定义算子加载","slug":"自定义算子加载","link":"#自定义算子加载","children":[]},{"level":3,"title":"日志与告警","slug":"日志与告警","link":"#日志与告警","children":[]}]},{"level":2,"title":"OM 文件结构解读","slug":"om-文件结构解读","link":"#om-文件结构解读","children":[{"level":3,"title":"解析与统计脚本要点","slug":"解析与统计脚本要点","link":"#解析与统计脚本要点","children":[]}]},{"level":2,"title":"ACL 推理编程模型","slug":"acl-推理编程模型","link":"#acl-推理编程模型","children":[{"level":3,"title":"C 语言最小示例（核心片段）","slug":"c-语言最小示例-核心片段","link":"#c-语言最小示例-核心片段","children":[]},{"level":3,"title":"Python 封装思路","slug":"python-封装思路","link":"#python-封装思路","children":[]}]},{"level":2,"title":"性能与初步调优策略","slug":"性能与初步调优策略","link":"#性能与初步调优策略","children":[]},{"level":2,"title":"常见错误分类与排查路径","slug":"常见错误分类与排查路径","link":"#常见错误分类与排查路径","children":[]},{"level":2,"title":"质量保障与自动化流水线","slug":"质量保障与自动化流水线","link":"#质量保障与自动化流水线","children":[{"level":3,"title":"精度对齐示例指标","slug":"精度对齐示例指标","link":"#精度对齐示例指标","children":[]}]},{"level":2,"title":"Dump / Profiling / 调试手段","slug":"dump-profiling-调试手段","link":"#dump-profiling-调试手段","children":[]},{"level":2,"title":"动态 Shape 策略与内存规划","slug":"动态-shape-策略与内存规划","link":"#动态-shape-策略与内存规划","children":[]},{"level":2,"title":"精度验证流程与脚本要点","slug":"精度验证流程与脚本要点","link":"#精度验证流程与脚本要点","children":[]},{"level":2,"title":"安全与合规考量","slug":"安全与合规考量","link":"#安全与合规考量","children":[]},{"level":2,"title":"章节小结","slug":"章节小结","link":"#章节小结","children":[]},{"level":2,"title":"实践任务","slug":"实践任务","link":"#实践任务","children":[]}],"git":{"createdTime":1752741756000,"updatedTime":1758457965000,"contributors":[{"name":"zhouxzh","username":"zhouxzh","email":"zhouxzh@gdut.edu.cn","commits":2,"url":"https://github.com/zhouxzh"},{"name":"idsefa","username":"idsefa","email":"hhc92611@gmail.com","commits":1,"url":"https://github.com/idsefa"},{"name":"Xianzhong Zhou","username":"Xianzhong Zhou","email":"zhouxzh@gdut.edu.cn","commits":1,"url":"https://github.com/Xianzhong Zhou"}]},"readingTime":{"minutes":9.1,"words":2729},"filePathRelative":"book/chapter2.md","localizedDate":"2025年9月4日"}');export{p as comp,r as data};
